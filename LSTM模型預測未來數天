###過去30天預測未來30天，共預測30天

import pandas as pd
import numpy as np
import math 
import matplotlib.pyplot as plt 
import keras 
import pandas as pd 
import numpy as np 
from keras.models import Sequential 
from keras.layers import Dense 
from keras.layers import LSTM 
from keras.layers import Dropout 
from keras.layers import * 
from sklearn .preprocessing import MinMaxScaler 
from sklearn.metrics import mean_squared_error 
from sklearn.metrics import mean_absolute_error 
from sklearn.model_selection import train_test_split 
from keras.callbacks import EarlyStopping

#----------read data---------------------------------------------------------------------------------------------------
f=open('D:/even.wang/Desktop/新鉅/3. python/data/stock2610.csv')
data = pd.read_csv(f)
df2 = data[['date','close']]

#----------only "close"-------------------------------------------------------------------------------------------------
training_set = df2.iloc[:7197, 1:2].values 
test_set = df2.iloc[7197:, 1:2].values

#----------特徵縮放------------------------------------------------------------------------------------------------------
sc = MinMaxScaler(feature_range = (0, 1)) 
training_set_scaled = sc.fit_transform(training_set)

#----------創建一個具有 30 個時間步長和 1 個輸出的數據結構------------------------------------------------------------------
np.random.seed(10)
X_train = [] 
y_train = [] 
for i in range(30,60): 
    X_train.append(training_set_scaled[i-30:i, 0]) 
    y_train.append( training_set_scaled[i:i+30, 0]) 
X_train, y_train = np.array(X_train), np.array(y_train)
X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1)) #values、#time-steps、#1 維輸出
#print(X_train[0])
#print(y_train[0])

model = Sequential()
#----------添加第一個 LSTM 層和一些 Dropout 正則化  Bidirectional------------------------------------------------------------
model.add(Bidirectional(LSTM(units = 100, return_sequences = True, input_shape = (X_train.shape[1], 1))))
#model.add(Dropout(0.2)) 
#return_sequences = True 適用於兩層以上

#----------添加第二個 LSTM 層和一些 Dropout 正則化---------------------------------------------------------------------------
model.add(Bidirectional(LSTM(units = 100, return_sequences = True)))
#model.add(Dropout(0.2))

#----------添加第三個 LSTM 層和一些 Dropout 正則化---------------------------------------------------------------------------
model.add(Bidirectional(LSTM(units = 100, return_sequences = True)))
#model.add(Dropout(0.2))

#----------添加第四個 LSTM 層和一些 Dropout 正則化---------------------------------------------------------------------------
model.add(Bidirectional(LSTM(units = 100, return_sequences = False)))
#model.add(Dropout(0.2))

#----------添加輸出層--------------------------------------------------------------------------------
model.add(Dense(units = 1))

#----------優化器、損失函數--------------------------------------------------------------------------
model.compile(optimizer = 'adam', loss = 'mean_squared_error')
#from keras.utils.vis_utils import plot_model
#plot_model(model, to_file='model_plot.png', show_shapes=True, show_layer_names=True)
#model.summary()

#----------訓練模型----------------------------------------------------------------------------------
history = model.fit(X_train, y_train, epochs = 200, batch_size = 128)
#plt.ylabel('loss')
#plt.xlabel('Epoch')
#plt.plot( history.history["loss"])

#----------測試資料-----------------------------------------------------------------------------------
dataset_train = df2.iloc[:7197, 1:2] 
dataset_test = df2.iloc[7197:, 1:2]

#----------合併資料(訓練)、資料(測試)，得到資料(total)，取資料(total)最後60(時間步數+預測筆數)筆，然後作歸一化以及2維轉3維。最後再作預測。----------
dataset_total = pd.concat((dataset_train, dataset_test), axis = 0)
inputs = dataset_total[len(dataset_total) - len(dataset_test) - 30:].values
inputs = inputs.reshape(-1,1)
inputs = sc.transform(inputs)
X_test = []
for i in range(30, 60):
    X_test.append(inputs[i-30:i, 0])
X_test = np.array(X_test)
X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))
print(X_test.shape)

#----------使用測試集進行預測--------------------------------------------------------------------------
predicted_close = model.predict(X_test) 
predicted_close = sc.inverse_transform(predicted_close)


#----------可視化結果----------------------------------------------------------------------------------
plt.plot(test_set, color = 'red', label = 'Real close') 
plt.plot(predicted_close, color = 'blue', label = 'Predicted close') 
plt.title('Close Prediction-3-epoch=200') 
plt.xlabel('day')
#plt.xticks(rotation=60)
plt.ylabel('close')
plt.legend() 
plt.show()

mse = np.round(mean_squared_error(dataset_test['close'].values, predicted_close), 3)
print(mse)
